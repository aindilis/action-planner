<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html dir='ltr' xmlns='http://www.w3.org/1999/xhtml' xmlns:b='http://www.google.com/2005/gml/b' xmlns:data='http://www.google.com/2005/gml/data' xmlns:expr='http://www.google.com/2005/gml/expr'>
<head>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<script type="text/javascript">(function() { var a=window;function c(b){this.t={};this.tick=function(d,i,e){e=e?e:(new Date).getTime();this.t[d]=[e,i]};this.tick("start",null,b)}var f=new c;a.jstiming={Timer:c,load:f};try{var g=null;if(a.chrome&&a.chrome.csi)g=Math.floor(a.chrome.csi().pageT);if(g==null)if(a.gtbExternal)g=a.gtbExternal.pageT();if(g==null)if(a.external)g=a.external.pageT;if(g)a.jstiming.pt=g}catch(h){};a.tickAboveFold=function(b){b=b;var d=0;if(b.offsetParent){do d+=b.offsetTop;while(b=b.offsetParent)}b=d;b<=750&&a.jstiming.load.tick("aft")};var j=false;function k(){if(!j){j=true;a.jstiming.load.tick("firstScrollTime")}}a.addEventListener?a.addEventListener("scroll",k,false):a.attachEvent("onscroll",k);
 })();</script>
<meta content='true' name='MSSmartTagsPreventParsing'/>
<meta content='blogger' name='generator'/>
<link href='http://www.blogger.com/favicon.ico' rel='icon' type='image/vnd.microsoft.icon'/>
<link href='http://taeb-blog.sartak.org/' rel='canonical'/>
<link rel="alternate" type="application/atom+xml" title="The Tactical Amulet Extraction Bot - Atom" href="http://taeb-blog.sartak.org/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="The Tactical Amulet Extraction Bot - RSS" href="http://taeb-blog.sartak.org/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="The Tactical Amulet Extraction Bot - Atom" href="http://www.blogger.com/feeds/2067582268125708908/posts/default" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.blogger.com/rsd.g?blogID=2067582268125708908" />
<link rel="me" href="http://www.blogger.com/profile/01037423036129960255" />
<link rel="openid.server" href="http://www.blogger.com/openid-server.g" />
<!--[if IE]> <script> (function() { var html5 = ("abbr,article,aside,audio,canvas,datalist,details," + "figure,footer,header,hgroup,mark,menu,meter,nav,output," + "progress,section,time,video").split(','); for (var i = 0; i < html5.length; i++) { document.createElement(html5[i]); } })(); </script> <![endif]-->
<title>The Tactical Amulet Extraction Bot</title>
<link type='text/css' rel='stylesheet' href='http://www.blogger.com/static/v1/widgets/1743847221-widget_css_bundle.css' />
 <link rel="stylesheet" type="text/css" href="http://www.blogger.com/dyn-css/authorization.css?targetBlogID=2067582268125708908&zx=939d1bff-c631-4ae6-8dec-1a48f4a667cd"/>
<style type="text/css">#navbar-iframe { display:block }
</style>

<style id='page-skin-1' type='text/css'><!--
/*
* Tekka
* style modified from glish: http://www.glish.com/css/
*
* Updated by Blogger Team
*/
/* Variable definitions
<Variable name="mainBgColor" description="Page Background Color"
type="color" default="#f5f5f5">
<Variable name="mainTextColor"  description="Text Color"
type="color" default="#000000">
<Variable name="dateHeaderColor" description="Date Header Color"
type="color" default="#808080">
<Variable name="mainLinkColor" description="Link Color"
type="color" default="#0000ff">
<Variable name="mainVisitedLinkColor" description="Visited Link Color"
type="color" default="#800080">
<Variable name="sidebarBgColor" description="Sidebar Background Color"
type="color" default="#ffffff">
<Variable name="sidebarTextColor" description="Sidebar Text Color"
type="color" default="#000000">
<Variable name="sidebarTitleColor" description="Sidebar Title Color"
type="color" default="#000000">
<Variable name="sidebarLinkColor" description="Sidebar Link Color"
type="color" default="#0000ff">
<Variable name="sidebarVisitedLinkColor" description="Sidebar Visited Link Color"
type="color" default="#800080">
<Variable name="bodyFont" description="Text Font"
type="font" default="normal normal 120% serif">
<Variable name="startSide" description="Start side in blog language"
type="automatic" default="left">
<Variable name="endSide" description="End side in blog language"
type="automatic" default="right">
*/
body {
margin-top:0px;
margin-right:0px;
margin-bottom:0px;
margin-left:0px;
font-size: small;
background-color: #f5f5f5;
color: #000000;
}
#content-wrapper {
margin-top: 0px;
margin-right: 0px;
margin-bottom: 0;
margin-left: 5px;
}
h1 {
font-variant: small-caps;
text-align: center;
}
h1 a, h1 a:link, h1 a:visited {
text-decoration:none;
color: #000000;
}
.description {
text-align: center;
padding-top:10px;
}
h2.date-header {
border-bottom:none;
font-size: 130%;
text-align:left;
margin-top:20px;
margin-bottom:14px;
padding:1px;
padding-left:17px;
color: #808080;
font-weight: normal;
}
h3.post-title {
font-size: 150%;
font-weight:bold;
}
.post h3 a,
.post h3 a:visited {
color: #000000;
}
.post {
padding-left:20px;
margin-bottom:20px;
text-indent:10px;
padding-right:20px;
line-height:22px;
}
.post-footer {
margin-bottom:15px;
margin-left:0px;
font-size: 87%;
}
#comments {
margin-left: 20px;
}
.feed-links {
clear: both;
line-height: 2.5em;
margin-left: 20px;
}
#blog-pager-newer-link {
float: left;
margin-left: 20px;
}
#blog-pager-older-link {
float: right;
}
#blog-pager {
text-align: center;
}
#main {
float:left;
padding-bottom:20px;
padding:0px;
width:67%;
font: normal normal 120% 'Droid Serif', 'Gentium', serif;
word-wrap: break-word; /* fix for long text breaking sidebar float in IE */
overflow: hidden;     /* fix for long non-text content breaking IE sidebar float */
}
h1, h2, h3, h4, h5 {
font-family: Helvetica, sans-serif;
}
.sidebar h2 {
font-weight:bold;
font-size: 150%;
color: #000000;
}
img {
display: block;
margin-right: auto;
margin-left: auto;
padding: 2px;
border: 2px solid #CCCCCC;
}
.aside {
background: #CCCCCC;
padding: 2%;
margin-left: 3%;
margin-right: 3%;
}
a {
text-decoration:none
}
a:hover {
border-bottom:dashed 1px red;
}
a img {
border: 0;
}
a {
color: #0000ff;
}
a:hover,
a:visited {
color: #800080;
}
#sidebar a {
color: #0000ff;
}
#sidebar a:hover,
#sidebar a:visited {
color: #800080;
}
#sidebar {
text-transform:none;
background-color: #ffffff;
color: #000000;
padding-left: 20px;
width: 30%;
float: right;
font: normal normal 120% 'Droid Serif', 'Gentium', serif;
border-left:2px dashed #000000;
word-wrap: break-word; /* fix for long text breaking sidebar float in IE */
overflow: hidden;     /* fix for long non-text content breaking IE sidebar float */
}
.sidebar .widget {
padding-top: 4px;
padding-right: 8px;
padding-bottom: 0;
padding-left: 0;
}
.profile-textblock {
clear: both;
margin-left: 0;
}
.profile-img {
float: left;
margin-top: 0;
margin-right: 5px;
margin-bottom: 5px;
margin-left: 0;
}
.clear {
clear: both;
}
.comment-footer {
padding-bottom: 1em;
}
p {
text-align: justify;
}

--></style>
<script type="text/javascript">
if (window.jstiming) window.jstiming.load.tick('headEnd');
</script></head>
<body>
<div class='navbar section' id='navbar'><div class='widget Navbar' id='Navbar1'><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener("load",
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<iframe src="http://www.blogger.com/navbar.g?targetBlogID=2067582268125708908&amp;blogName=The+Tactical+Amulet+Extraction+Bot&amp;publishMode=PUBLISH_MODE_HOSTED&amp;navbarType=BLUE&amp;layoutType=LAYOUTS&amp;searchRoot=http%3A%2F%2Ftaeb-blog.sartak.org%2Fsearch&amp;blogLocale=en&amp;homepageUrl=http%3A%2F%2Ftaeb-blog.sartak.org%2F" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" height="30px" width="100%" id="navbar-iframe" allowtransparency="true" title="Blogger Navigation and Search"></iframe>
<div></div></div></div>
<div id='outer-wrapper'><div id='wrap2'>
<!-- skip links for text browsers -->
<span id='skiplinks' style='display:none;'>
<a href='#main'>skip to main </a> |
      <a href='#sidebar'>skip to sidebar</a>
</span>
<div id='content-wrapper'>
<div id='crosscol-wrapper' style='text-align:center'>
<div class='crosscol section' id='crosscol'></div>
</div>
<div id='main-wrapper'>
<div class='main section' id='main'><div class='widget Header' id='Header1'>
<div id='header-inner'>
<div class='titlewrapper'>
<h1 class='title'>
The Tactical Amulet Extraction Bot
</h1>
</div>
<div class='descriptionwrapper'>
<p class='description'><span>
</span></p>
</div>
</div>
</div><div class='widget Blog' id='Blog1'>
<div class='blog-posts hfeed'>
<!-- google_ad_section_start(name=default) -->

          <div class="date-outer">
        
<h2 class='date-header'><span>Saturday, August 22, 2009</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='2735127143982367306'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/08/planar-taeb-ai.html'>Planar - a TAEB AI</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<p><a href="http://ais523.sartak.org/TAEB-AI-Planar/">TAEB::AI::Planar</a> is a NetHack AI, written as a plugin for   TAEB. (TAEB the framework does not contain AI-specific logic   itself; instead, it aims to be a general platform that can be   used both by AIs and by other programs that want to interact with   NetHack; for instance, it would be plausible to use TAEB to   implement an <a href="http://interhack.us">Interhack</a>-like program.) The first TAEB AI,   historically, is the one that is now called Behavioral (and which   was originally just part of TAEB itself before it was split out);   most TAEBs that you will see on <a href="http://alt.org/nethack">nethack.alt.org</a>, for instance,   run that AI. Planar is a newer attempt to create an AI, by me,   Alex Smith (ais523) and Stefan O&#8217;Rear (sorear); at present, it&#8217;s   used by the bots <a href="http://alt.org/nethack/player-top.php?player=TAEB523">TAEB523</a> and <a href="http://alt.org/nethack/player-top.php?player=sortaeb523">sortaeb523</a> (which run from much the   same codebase, but are generally configured differently).   Planar&#8217;s best score so far is 34179, in the large room at the end   of the second level of Sokoban, which was scored locally on my   computer; it died walking over a cockatrice corpse when blind and   gloveless, the dangers of which it hadn&#8217;t been told about.</p>    <p>Planar treats NetHack as a pathfinding exercise; just as a   computer would use a pathfinding algorithm to determine the   shortest route from one room to another, Planar uses pathfinding   algorithms to determine the best &#8216;route&#8217; from its current   situation to its eventual goal. The AI is based around resources,   which are things that the AI can spend, can use, or has to be   careful not to run out of (for instance, gold or hitpoints),   threats, which are things that can be mitigated or fixed, but   could cause plans to be more dangerous or which prevent them   working correctly if not fixed (for instance, monsters or a trap   on the current square), and plans, which are specific goals that   it aims for, along with an idea of how to accomplish them.</p>    <p>Here is how Planar goes about deciding what to do on any given   turn. (Note that although Planar remembers what it was thinking   on previous turns, it recalculates most things every turn to   allow for new information, rather than blindly continuing with   its previous plan.) Each stage of the calculation is accompanied   by a picture showing an actual situation from a game of NetHack   that Planar has played (in fact, they&#8217;re all from the same game),   and the text explains how Planar went about dealing with it.</p>    <h2 class="western">Threats</h2>    <p><img src="http://sartak.org/misc/blog/planar/threats.png" name="graphics1" id="graphics1" alt="Threats" align="bottom" border="0" width="561" height="360" /></p>    <p>The &#8216;start&#8217; of Planar&#8217;s main loop (that is, when it starts   dealing with the current turn, rather than the previous turn), is   checking for threats that might make plans more risky. In the   picture above, TAEB (the @ sign which appears inverse-video in   this screenshot because it has a blinking cursor on it) has   decided that it wants to eat the corpse (the % sign) on the   ground, probably because it&#8217;s relatively hungry and wants to get   to the corpse before it rots. Although in theory it could walk   directly to the corpse and eat it, there are two potential   problems; to the west is a nymph (a lowercase n) who would steal   its items if given a chance, and to the east is a golem (an   apostrophe) who, being a hostile monster, wants to beat the poor   TAEB up. (Incidentally, Planar always asks for more information,   if it&#8217;s available and doesn&#8217;t cost a turn, in order to analyse   the situation as well as possible; for instance, if the material   the golem was made of (relevant because it determines how   dangerous it is) were undeducible from its colour on-screen, it   would ask the framework to request NetHack to give more details,   in this case by sending a farlook command to examine it remotely   in detail.) The two monsters here are threats; the nymph is a   threat to the TAEB&#8217;s items (which will be a source of resources   such as nutrition, damage-potential, and armour), whereas the   golem will be a threat to the TAEB&#8217;s hitpoints (a resource in   themselves). Note that all threats, as well as everything else in   Planar, are quantified so that it knows their exact value. (There   are two ways to represent the value of things inside Planar; one   is as a list of amounts of resources, the other is as a number   that attempts to calculate the total value of all the resources   in question by using exchange rates. These alter according to the   amounts of the resources in question; for instance, normally one   hitpoint is considerably more valuable than one unit of   nutrition, but that rate would be rather different if the TAEB   were healthy but fainting from hunger.) In this case, it would   estimate the amount of theft the nymph would likely carry out   (and as any NetHack player knows, that&#8217;s generally more than you   can easily replace); and it would calculate the amount of damage   the golem could deal per turn in mêlée combat (taking the   worst-case scenario; Planar is just as scared of the Random   Number Generator as any human would be).</p>    <p>The threat-check will quickly try to work out how quickly, on   average, the monsters could get to each square on the map, and   assign a threat function to those squares that indicates how   damaging the threats could be if we tried to route to those   squares at a particular moment. This is shown in the tactical map   above; colder colours represent safer squares, with warmer   colours being squares that are more threatening. So, for   instance, going to the west past the nymph without dealing with   it first is likely to be suicidal, thus the whole area there is   filled with magenta (the worst possible colour); likewise, going   to the east past the golem without dealing with it first is also   a bad idea. The amount of threat that actually matters depends on   when we finish business on the square in question; the map above   shows the amount of threat (together with the amount of tactical   cost, which is insignificant on that diagram) on each square at   the first moment we can reach it, but carrying through   time-consuming plans on those squares would give the monsters   more time to catch up. As a result, the nearest unexplored   corridor is a safe blue, as the TAEB could outrun the monsters   along it (golems are rather slow, and the TAEB has a head-start   over the equally speedy nymph); but the second-nearest unexplored   corridor ends in a red square, because although the TAEB could   get away from the golem eventually, the golem would get a few   hits in as it walked past. So, if it was going exploring, it   would use the safer first path.</p>    <p>However, just now the TAEB isn&#8217;t exploring; it&#8217;s hungry. The   corpse shows up as brown on the above map, but that map (which   was generated from the tactical planning stage) is just taking   into account the length of time the corpse takes to walk to;   eating the corpse will also take some time, and the threat   function will give a higher threat value for a plan involving   eating the corpse once the time taken is known (which will be   calculated in the strategic planning stage).</p>    <p>There&#8217;s one other important task carried out by threat   checking; for each square on the map (to be precise, the current   level; as routing for other levels is cached, any threat   calculation for them would be ignored anyway), it tags the square   with information on how to mitigate the threat or threats that   can get there. So for instance, there will be a plan to Mitigate   the golem (i.e. kill it, eliminate it, or drive it away somehow)   in order to make it safer to eat the corpse. (After it&#8217;s killed   the golem, it&#8217;ll likely see that the nymph is also problematic,   and it will try to get rid of her too, probably by throwing sharp   pointy objects at her. This is another outcome of the threat   check; it&#8217;s rather dangerous to attack a nymph in mêlée if you   can help it, and the squares further away from her would show a   much lower risk as a result, meaning that projectiles would be   favoured over melee weapons.)</p>    <p>The bottom of the screen shows the decisions that the other   stages of the loop have made; strategic planning has decided that   it&#8217;s still worth eating the corpse, that getting rid of the golem   first is a good idea, and that mêlée is the best way to do it;   and tactical planning has decided that the best way to route near   the golem is to walk east of it until the square immediately to   its west. The chain of plans involved can be seen on the   penultimate line of the screen; the final (l) on the screen is   added by the framework, which knows that pressing l is the   correct way to walk to the east (whereas the AI would just have   returned a &#8220;walk east&#8221; action to the framework).</p>    <h2 class="western">Tactical planning</h2>    <p><img src="http://sartak.org/misc/blog/planar/tactical-planning.png" name="graphics2" id="graphics2" alt="Tactics" align="bottom" border="0" width="561" height="360" /></p>    <p>Once all the threats have been placed on the map, the next   step is to work out tactics for the turn. Again, this is done by   working out how expensive (in terms of resources) it is to move   to any given square on the map; but this time, it&#8217;s our own   routing we worry about, rather than that of the monsters.</p>    <p>The diagram above shows our TAEB just after it&#8217;s killed   another monster, again wanting to eat it. This time, the monsters   around are less threatening; there&#8217;s just an iguana (the nearby   colon) to worry about. Although this particular turn came to the   same conclusion as the last one analysed (kill the monster so you   can eat the corpse in peace), tactical planning does not care   about what the TAEB eventually ends up doing, but rather, how   best to get to each square on the map.</p>    <p>This is done in terms of tactical plans; a single tactical   plan contains a suggestion of how to get from one square to   another square, together with information on how risky it would   be (taken from the threat map and from information on the cost of   the action required). Plans in Planar are very specific; as   opposed to Behavioral&#8217;s behaviours, which are few in number and   general (such as FixStatus and Defend), a plan in Planar contains   information about exactly what is to be done (such as &#8216;move from   (12,10) to (13,10) by opening the door on (13,10) then walking   there&#8217;, which would have a cost in time based on how much time it   would likely take to force the door open). It would be entirely   common for multiple plans to be considered; for instance, in that   example with the door, Planar would also be considering kicking   that door down, which could be faster if, say, it were   approaching the door from the diagonal (as a broken doorway can   be entered diagonally, but one with a door in can&#8217;t be).</p>    <p>Tactical planning is a form of routing, in physical NetHack   space; however, unlike most other AIs, a large amount of AI logic   is done during tactical planning. For instance, Behavioral has a   behaviour to open doors so that they don&#8217;t block routing later;   in Planar, opening doors is only done if they&#8217;re in the way.   Likewise, Planar will push boulders (trying not to block   corridors in the process) and even tunnel through walls if that&#8217;s   necessary to go where it wants to go, or if that&#8217;s the fastest   way; the tactical planning stage will have a plan all ready for   any strategic plan that needs to move to the square, for whatever   reason. The actual routing is done via Dijkstra&#8217;s algorithm, in   order to gain routing information for the whole map at once.</p>    <p>The diagram above shows routing costs, as determined by   tactical planning, to the whole level; as opposed to the previous   example, TAEB523 now has a pickaxe, and thus can route into the   walls if it wants to. Note that many of the nearby walls are   considerably more expensive to route to than the corridors and   rooms near them; but the distant walls have comparable costs to   the nearby rooms. The reason for this is that digging nearby   takes a sufficiently long time that the iguana will catch up to   the TAEB and attack; but digging distantly would happen in the   future, after the iguana had already been outrun.</p>    <p>At the end of the tactical planning stage, therefore, it&#8217;s   possible to quickly and efficiently answer any query from the   strategic planning stage about how to get somewhere, and how   risky doing so would be. (Incidentally, in Planar, &#8216;risky&#8217; is a   technical term meaning &#8216;difficult, expensive, or both&#8217;.) As a   result, huge numbers of strategic scenarios can be tried, to   determine which one works best.</p>    <h2 class="western">Strategic planning</h2>    <p><img src="http://sartak.org/misc/blog/planar/strategic-planning.png" name="graphics3" id="graphics3" alt="Strategy" align="bottom" border="0" width="562" height="360" /></p>    <p>Strategic planning is the heart of Planar; threat checks and   tactical planning are simply calculating information so that   strategic planning can refer to it quickly, whereas strategic   planning decides what, overall, the bot is actually going to   do.</p>    <p>To start with, there are several standard plans that work on   improving Planar&#8217;s resource situation; for instance, eating when   hungry, collecting ammo, and picking up useful items. (An item is   useful enough to be picked up if its value to us, say as a source   of food or as a backup armour in case the one we&#8217;re already   carrying around turns out to be cursed, is higher than the   drawbacks, such as its weight.) This gradual improvement of the   character is known as resource conversion; if the TAEB can manage   a net gain in resources, it does so, ignoring the main plan for a   while (and going for the largest gains first). Therefore, there&#8217;s   no need for every major plan to take the details of things like   feeding and shopping into account; it&#8217;ll happen automatically   without a specific request to suppress it. If none of the   resource-conversion plans can produce an improvement, though, the   main plan takes over; this is a user-configurable overall goal   that the bot is trying to accomplish. In the example above, for   instance, the main plan is SlowDescent, which explores the   dungeon from the top down, thoroughly exploring each level before   going onto the next one.</p>    <p>In order to determine how to accomplish the goal in question,   strategic planning basically does routing in plan-space, again   using Dijkstra&#8217;s algorithm. In this case, the steps on the route   are plans that make other plans possible. So, for instance, the   chain of plans shown in the picture above are SlowDescent | by   exploring [this level] | by exploring [a specific square] &#8211; by   walking towards it; the final plan there is a tactical plan, the   rest are strategic. In order to come to this decision, Planar   will start by asking SlowDescent if it can be accomplished   directly; the answer in this case is always &#8216;no&#8217;, because there   is no associated action (it&#8217;s a &#8220;metaplan&#8221;, which is defined in   terms of plans rather than in terms of actions). As a result,   it&#8217;ll look for plans that make up parts of the slow descent, or   make it easier to accomplish; in this case, the plans in question   will be exploring level 1, exploring level 2, exploring level 3,   and exploring level 4, in that preference order. (There&#8217;s no   problem with more than one plan having the same preference; in   that case, Planar would simply take the cheapest, leading to a   &#8220;nearest first&#8221; exploration of the dungeon. However, SlowDescent   is specifically trying to explore from the top downwards.)</p>    <p>Each of the level exploration plans are likewise metaplans,   which suggest exploring particular locations on the level in   question. Although Planar would like to explore on the first or   second floors, if possible, those floors were apparently explored   out at the time; so as the next-best option, it would consider   the exploration spots on the third floor. (The picture above is   showing the cache of exploration spots on the level, cached for   speed; warm colours show squares in need of exploration, cool   colours showing squares that have already been explored.) This   time, all the exploration spots have the same preference level;   so the least risky exploration is taken, which in this case, with   no visible threats, is the nearest. (The tactical planning stage   will already have the risk of reaching each of the exploration   spots, as well as everywhere else in the dungeon,   ready-calculated so that it can be given very quickly when   requested; so despite the large number of exploration spots   shown, strategic planning will not take much time.)</p>    <p>Before enacting the plan in question, various checks are done.   Plans are skipped if they require more of any resource than is   available to spend; so, for instance, exploring one square is   normally fine, but if that square is next to a demon prince and   we&#8217;re low on hitpoints, it will be considered far too risky in   terms of hitpoints to attempt. (A different plan would be   favoured, therefore; probably running away to carry out business   in another part of the dungeon.) Likewise, something can be too   risky in terms of anything else. The alternative plans suggested   by threat check will also be considered, to see if eliminating   the threat first and then carrying out the plan will be a better   idea than just carrying out the plan directly. A plan can be   suppressed by the previous turn&#8217;s plan, to avoid losing sight of   a slightly-longer-term goal in favour of a short-term goal (so,   for instance, it will unequip a shield in order to wield a   two-handed digging tool, even though normally improving its   armour would be more urgent than digging through a wall).   Finally, a plan might not be enacted due to success measurement   deciding that it is doomed to fail, or create an oscillation,   based on observations rather than on known information.</p>    <h2 class="western">Success measurement</h2>    <p><img src="http://sartak.org/misc/blog/planar/success-measurement.png" name="graphics4" id="graphics4" alt="Success" align="bottom" border="0" width="562" height="362" /></p>    <p>Once Planar has decided on a plan, it will find out what   action is associated with it, and tell the framework that that&#8217;s   the desired action for the turn. After the framework has   processed the results of the action and asked for the next one,   though, Planar does after-the-fact processing on the current turn   before moving on to consider the next turn&#8217;s plan. In particular,   it&#8217;s trying to determine whether the plan worked as expected or   not, and whether it&#8217;s stuck in an oscillation.</p>    <p>Each plan comes with a test to determine whether or not it   accomplished what it set out to do. For instance, a plan to open   a door will check to see if the door is now open; if it isn&#8217;t, it   will check to see if it was for a known reason (doors in NetHack   sometimes randomly fail to open, which is not a problem), or if   it was for an unknown reason (for instance, Planar doesn&#8217;t yet   know it can&#8217;t open a door if it&#8217;s been forced into jackal form by   a werejackal, but it can determine that it tried to open a door,   it didn&#8217;t work, and it doesn&#8217;t know why). If a plan fails   unexpectedly, it won&#8217;t be retried for some time, which increases   sharply the more times the plan in question has failed in a row.   (There&#8217;s an exception to this; if something happens to make   Planar think that the situation has changed, for instance if a   tile relevant to the plan in question changes glyph or one of the   plans marked as part of or an alternative to the plan succeeds,   it will try again instantly.) This happens for both strategic and   tactical plans; as always, failure will simply cause it to seek   alternatives. In this way, Planar can get around deficiencies in   either its own, or the framework&#8217;s, understanding of NetHack;   this ability to determine what works by experiment will helpfully   aid it in handling unexpected situations (whereas Behavioral   normally responds to such situations with an infinite loop as it   tries a doomed action over and over again).</p>    <p>More subtly, a plan can seem to be working correctly, but   leave TAEB stuck in an infinite loop; this is the dreaded   &#8220;oscillation&#8221; that&#8217;s so common in NetHack-playing AIs. The   picture above shows TAEB near a throne room (full of letters   representing monsters); it looks like a good place to explore   from afar, but upon approaching more closely, it&#8217;s possible to   see that it&#8217;s full of monsters. Planar tends to be cautious   around monsters, especially when there are alternative plans   available; so it would walk away from the throne room, forget the   location of the monsters (neither the TAEB framework nor Planar   currently has any way to track the locations of monsters that are   out-of-sight), walk towards it again, and repeat. The repeated   indecision in which plan to accomplish is detected in success   measurement; and as a result, the success measurement   deliberately makes up its mind to try one plan or the other, by   temporarily interfering with both the strategic planning and   tactical planning stages to help force a particular decision. In   the map above, therefore, most of the routing map is unexpectedly   grey, rather than the usual blue; this is because success   measurement has detected an oscillation and decided to allow only   plans that move towards the throne room for a few turns (by   causing routing to fail when moving away from it). As a result,   the TAEB has decided to look at the items on the floor in the   room instead; and has concluded that the safest way to do that is   to slaughter the inhabitants of the throne room, picking them off   at range using projectiles. (The messages at the top show that   the previous turn, it threw something at a monster and killed it;   it wants to do that again, but needs to reposition itself   first.)</p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>ais523</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/08/planar-taeb-ai.html#comments' onclick=''>3
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-202040633'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=2735127143982367306' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/AI' rel='tag'>AI</a>,
<a href='http://taeb-blog.sartak.org/search/label/design' rel='tag'>design</a>,
<a href='http://taeb-blog.sartak.org/search/label/Planar' rel='tag'>Planar</a>,
<a href='http://taeb-blog.sartak.org/search/label/taeb' rel='tag'>taeb</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-2735127143982367306"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-2735127143982367306")); } </script>

            </div></div>
          

          <div class="date-outer">
        
<h2 class='date-header'><span>Friday, June 12, 2009</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='6626062578908011637'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/06/synchronizing-with-nethack.html'>Synchronizing with NetHack</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<p>One of the nastiest problems TAEB has to solve is also one of the
most mundane.  If you've ever played a game over a network or on a
heavily loaded computer, you are probably familiar with lag and the
problems it creates.  While NetHack, as a turn-based game, does not
suffer from directly lag-caused <em>deaths</em>, it is still very
difficult to make moves sensibly when the responses are delayed.</p>

<p>Bots like TAEB also suffer from lag, indeed much worse than people
do.  Twenty milliseconds is quite unnoticeable for a human but is an
eternity for a bot, and even at that timescale issues of finding the
end of a turn are normal.  Furthermore, bots are much less able to
recover from partial updates than people are, due to the lack of
sensible error-recovery.</p>

<img src="http://sartak.org/misc/blog/taeb/halfframe.png"/>

<p>Presumably, the player just exited a full-screen menu or changed
dungeon level.  A full screen redraw for NetHack is larger than the <a
    href="http://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a>
of most networks, and due to lag, the second packet has been delayed
significantly.  (This doesn't require weird conditions; TCP normally
waits until data has been successfully received before sending more.)
As a result, the lower half of the current frame is black.  TAEB, on
seeing this frame, makes a couple of damaging inferences:</p>

<ul> <li>The lower half of the level has turned into solid rock.  This
    is an especially nasty case if the redraw was caused by stairs, as
    TAEB interprets large areas of new stone to indicate a brand new
    unexplored level, corrupting the dungeon graph.</li>

<li>The bottom line is all spaces and unparsable, resulting in error
spam and no stats.</li> </ul>

<p>Clearly, bots need a reliable way to tell when NetHack is done
sending output for the turn.  There have been several approaches to
this problem over the years.</p>

<h3>Consistently slow</h3>

<p>One of the oldest and simplest approaches is simply to sleep for
one second or so after every move, to wait for NetHack.  This works,
most of the time.  It has two major flaws; first it is very slow,
second it is unreliable - if lag spikes above 1 second, the bot may
see an incomplete frame.  Nevertheless, it is very simple to implement
and has been used in several efforts.</p>

<h3>Avoiding the issue</h3>

<p>Another approach which has been historically used, most famously by
the <a href="http://www.itctel.com/~apwhite/andrew.html">Angband
    Borg</a> and <a
    href="http://www.cs.princeton.edu/~appel/papers/rogomatic.html">Rog-o-matic</a>,
is to link the bot into the game's input routines.  In theory, this is
foolproof, but it carries dangers of a different sort, in addition to
the obvious restriction to local games.</p>

<p>If done incautiously, the linking can affect game mechanics or leak
information, thus compromising the validity of the bot effort.
Modifying the game requires a very in-depth knowledge of NetHack's
implementation, which is very unclean and non-transparent in places.
Furthermore, requiring the bot to be linked into NetHack greatly
complicates the build process; the bot cannot be built or distributed
as a self-contained object unless all of NetHack is duplicated,
prohibitive effort for many starting projects.   As such, the linking
approach is very rarely used.</p>

<p>We want TAEB to play in <a
    href="http://nethack.devnull.net/">tournaments on public
    servers</a>, which precludes linking.</p>

<h3>Inline pings</h3>

<p>One approach which is often proposed, but sadly does not work, is
the inline ping.  Simply send an invalid command after every real
command, and wait for the error.  Unfortunately, there is no command
which is invalid in every context in NetHack.  Not even control-r to
redraw the screen; it fails in prompts and menus.</p>

<h3>Telnet ping/pong</h3>

<p>Invented by Sartak for NetHack fairly early on, and the most common
method in use today (in particular, <a
    href="http://github.com/sartak/TAEB/blob/master/lib/TAEB/Interface/Telnet.pm">TAEB
    uses this</a>), this relies on telnet as a side channel.  A bot
connects to a telnet server using a raw TCP socket, and implements the
protocol itself; after every command is sent, the bot attempts to
negotiate an invalid telnet stream option (<tt>DO 99</tt>).<p>

<p>When a telnet daemon receives the packet containing the command, it
sees an option it does not support and responds in failure (<tt>WONT
    99</tt>), then passes the command off to NetHack.  Shortly
afterward, NetHack's response is responded to the bot.  Thus, the bot
receives NetHack's response very shortly after the "pong".  In effect,
the telnet options are used as a side channel to dynamically measure
network lag.  Since under normal conditions network lag is the
dominant component of total lag, this gives the bot a very good idea
of when the output should be expected.</p>

<p>The reliability of this approach is improved by kernel packet
coalescing, also known as <a
    href="http://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle's
    algorithm</a>.  When the pong is sent, the network implementation
at the server waits a short time to potentially send a larger packet;
if packet sending is low-priority, this will additionally tend to be
delayed until NetHack is done calculating.  With the pong and the
response generally in the same packet, they are guaranteed to arrive
at the bot at exactly the same time.</p>

<p>While good enough for bots, this approach is not quite foolproof.
If NetHack takes a long time to reply to a command, due to system
load, slow execution (there are several quadratic algorithms in the
game, most notably monster movement and item stack sorting), or simply
being swapped out, it is possible for the kernel to time out the
attempt to coalesce, and the pong will arrive significantly before the
output.  This has been the source of several unreproducible errors in
TAEB.</p>

<p>This approach is also limited to telnet servers.  It does not help
at all with lag as it occurs on heavily-loaded local systems, and does
not work well with other network protocols.  In principle SSH could be
used, however the vastly higher complexity of the SSH protocol makes a
custom implementation prohibitively difficult.</p>

<h3>Expectations and Confusion</h3>

<p>Will Noble (futilius)'s <i>bridey</i> works on an entirely
different principle from the other bots.  Instead of relying on
out-of-band data to find complete frames, bridey is more like a human
in that it waits for a frame that looks complete.  The code which
generates actions also provides a predicate for a sensible-looking
result; fully filled bottom line, cursor on the character, etc.  When
an action is run, bridey waits for a frame that satisfies the
predicate.  To guard against programming oversights, the predicates
are made partially dependant on wait time, and become more lenient as
more data has had a chance to arrive.</p>

<p>Actually, bridey combines this with other mechanisms above; the
time, as it is used in predicates, is measured in telnet ping/pong
cycles.  For instance, the move action has a final timeout of 4
cycles.  This allows the reliability of the expect system to partially
stack on the reliability of ping/pong.  bridey, like TAEB, uses simple
sleeps on the local interface.</p>

<h3>Abusing POSIX Job Control for Fun and Profit</h3>

<p>In 2008 I developed a novel method, which is currently being
adopted by TAEB for the local interface.  NetHack is single threaded
and makes very little use of asynchronous calls, so when it is blocked
on tty input it cannot possibly generate output until more keys
arrive.  So, if we could somehow find out when NetHack blocks, we
would solve the synchronization problem permanently - unlike the
methods above, this is immune to system load.</p>

<p>On the surface, finding out when a process blocks would seem to
require low-level, privileged, and generally highly nonportable code.
However, we are not the first user of the information.  It is possible
in UNIX to move processes between the foreground and background at
will; if it were possible for background processes to read keyboard
input, chaos would result.  The traditional solution is for the kernel
to stop any process when it attempts to read in the background.
Stops, like deaths, result in <tt>wait()</tt> events; this is
necessary in order that the shell may continue them.</p>

<p>With this insight, the solution seems fairly obvious - simply put
NetHack in the background, then when it stops, let it read.  There are
a few complications in this, though.  First, it's not possible to
simply shovel data into a stopped reader; it has to be briefly
continued in the foreground.  How long is briefly?  Depends on...
system load.  Fortunately, there is a trick we can use to eliminate
inaccuracy - check for data on the virtual keyboard, with ourselves in
the foreground.  If we see anything, the slave needs to read more, and
we re-continue it, using exponential backoff.  Of course, data typed
is not always immediately available due to line-buffering and various
forms of special-key processing - but that applies to us too, so we
still get the right answer.</p>

<p>Even with that settled, POSIX only allows a process to use job
control if it lives inside the pseudo-terminal.  That means, we need
to fork a slave in order to do the actual manipulation, and
communicate using pipes.</p>

<p>This is very unusual activity terminal driver, and it has exposed
two bugs in the BSD kernel so far.  First, in all known versions of
BSD, a process which reads in the background does not actually receive
the stop signal until it returns to user mode; but it returns to user
mode only once the wait for terminal data completes!  In regular
usage, this is masked, because when you type <tt>bg</tt> all waiting
threads are woken, but it was a killer for us; the eventual workaround
I found was to briefly change the terminal blocking mode, thus forcing
the kernel to reconsider all active blocks.  Finding this bug, and the
workaround for it, took an annoyingly long amount of time.</p>

<p>Another bug the project found was that the BSD kernel does a
one-second sleep whenever a process that is already in the background
tries to read.  The reasons for this are quite unclear, but it has the
effect of killing performance of this approach.  Fortunately, recent
versions of Darwin (OS 10.5.7 is known to work) have a rewritten sleep
system, and this call is no more.</p>

<p>A comparatively minor issue was found in Linux; attempting to read
from an idle psuedoterminal master fails with a "No such device"
error, instead of the EOF return that would be expected of devices
with pipe semantics.  I'm not sure if this is a bug, but it did
require workaround code.</p>

<p>This method is implemented in the <tt><a
        href="http://search.cpan.org/~sorear/IO-Pty-HalfDuplex-0.01/">IO::Pty::HalfDuplex</a></tt>
perl module.</p>

<h3>Variations on the theme</h3>

<p>Job control abuse works pretty well on Linux and Darwin, but what
if you're on a different platform?  Well, there's always low-level,
privileged, and generally non-portable code.  As seems to often be the
case with hacks like this, it usually takes the form of a debugger API
abuse; set breakpoints on the functions that can read from the
terminal, and arrange to capture output somehow.  These approaches
share a common liability; debugger interfaces are highly
security-sensitive and are often in some way disabled.</p>

<ul> <li>On most UNIXes (including the BSDs) there is a system call
    <tt><a
            href="http://www.freebsd.org/cgi/man.cgi?query=ptrace&sektion=">ptrace</a></tt>
    which fits the bill perfectly.  Unfortunately, while the style of
    <tt>ptrace</tt> is virtually identical everywhere, no two UNIXes
    implement the call in exactly the same way.  <tt>ptrace</tt>
    implements security by refusing to trace processes of other users
    and denying user and group changes while active; this is a real
    bother for us, as NetHack is normally installed setgid - it
    escalates its group to one that can write to the saves and
    scoreboard.</li>

    <li>Windows has a debugger interface which is well documented and
    consistent across versions.  Nice?  Well, Windows also has, last
    time I counted, 30 different documented ways to read from the
    console.  Writing the correct traps to catch them all would be
    interesting, to say the least.</li>

    <li>Ironically, the best chances seem to exist on DOS.  Programs
    are debugged by directly hooking the operating system, allowing
    for a fully consistent interface, and there are very few paths for
    keyboard reading.  Unfortunately, CPAN on DOS is non-functional,
    and installing any large Perl system without it is extremely
    tedious.</li>

    <li>Departing from the trend of debuggers, it is also possible on
    the BSDs to simply read the process status.  Compared to the
    ptrace method, this has the advantage of working on segid
    processes, but requires polling.</li> </ul>

<p>I plan to implement most of these in
<tt>IO::Pty::HalfDuplex</tt>.</p>

<h3>Conclusion</h3>

<p>In the field of bot writing, even the simplest things can prove
almost insurmountably complex.  This is very evident in dealing with
lag, both network and loading.  Lag-related problems are a major cause
of unreproducable faults in even the most sophisticated NetHack bots.
Many of the simplest approaches to controlling lag are deeply flawed
and will make debugging difficult.  Let this be a lesson to everyone
who wants to start from scratch.  Fortunately, you don't have to; TAEB
is designed to be a framework, to support additional AIs easily.</p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>sorear</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/06/synchronizing-with-nethack.html#comments' onclick=''>3
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1964260081'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=6626062578908011637' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/design' rel='tag'>design</a>,
<a href='http://taeb-blog.sartak.org/search/label/library' rel='tag'>library</a>,
<a href='http://taeb-blog.sartak.org/search/label/nethack' rel='tag'>nethack</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-6626062578908011637"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-6626062578908011637")); } </script>

            </div></div>
          

          <div class="date-outer">
        
<h2 class='date-header'><span>Sunday, June 7, 2009</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='8115315029840954802'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/06/anatomy-of-step.html'>Anatomy of a Step</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<p>Several people have asked to see more articles about TAEB's architecture. Even after working with the codebase for a year and a half, I am still very happy with the design. My previous attempts at writing a NetHack bot lasted only a month or two before collapsing under their limitations. However, I think we finally got it <em>right</em> with TAEB, so I enjoy sharing what we have created.</p>

<p>To introduce the important components of TAEB, I am going to walk through TAEB's "main loop". We call each iteration of the main loop a "step". Each step vaguely resembles iterations of NetHack's own main loop. Note that this is <em>completely</em> unrelated to NetHack's turn counter. Due to the speed system, command repetition ("search for twenty turns"), and even paralysis, steps do not correspond with turns. The only similarity is that both counters increase monotonically. Today, we care only about steps, not turns.</p>

<h3>Input</h3>

<p>The first thing TAEB does is read input from NetHack. This can involve reading from a socket (as in <tt>TAEB::Interface::Telnet</tt>) or reading from a pseudo-terminal (as in <tt>TAEB::Interface::Local</tt>). I will eventually write a post about the mechanics of simply deciding when NetHack is done sending data. It is not at all trivial. (update: <a href="http://taeb-blog.sartak.org/2009/06/synchronizing-with-nethack.html">here's that post</a>)</p>

<p>NetHack prints a stream of characters. Since it provides a full text user interface with two-dimensional maps and colors, NetHack prints <i>escape sequences</i>. These escape sequences encode commands such as "change the pen color to red" (<tt>\e[31m</tt>) or "go to cell (5, 12)" (<tt>\e[12;5H</tt>). We run all input through <a href="http://search.cpan.org/perldoc?Term::VT102"><tt>Term::VT102</tt></a> to parse and handle these escape sequences. <tt>Term::VT102</tt> then lets us ask high-level questions like "what is the text of row 23?" or "what color is cell (59, 6)"? We have a subclass <tt>TAEB::VT</tt> that lets us ask additional questions, such as "is the text 'Hit return to continue:' present on the terminal?"</p>

<p>We now have something resembling what the player would see (a two-dimensional, colored block of text). The next task is to <em>understand</em> what is on the screen. Consider the following NetHack terminal:</p>

<img src="http://sartak.org/misc/blog/taeb/screenscraper.png" />

<p class="aside">As a human, you can figure out a lot of what is going on, even if you have never played NetHack. You can see that the player is in combat with a goblin. From the bottom lines, you can guess that the player is stuffed with food, and probably the character's name. If you have played NetHack, you can recognize several more things. The character is a wizard (evidenced by the <i>Evoker</i> title). There is a general store in the top left room. The character is currently on the bottom of the screen, with a goblin just north of him. You can identify the seven <i>rooms</i> of the level, and the features of the dungeon (like stairs, a fountain, and many doors).</p>

<p>Such analysis is the job of two components, <tt>TAEB::ScreenScraper</tt> and <tt>TAEB::World::Cartographer</tt>. The Cartographer analyzes the map to populate internal level and tile information, while the ScreenScraper handles other input (mostly English text). The ScreenScraper runs first, parsing messages to publish <a href="http://taeb-nethack.blogspot.com/2009/03/taeb-pubsub-and-announcements.html">announcements</a>. The rest of the system does not have to worry about the content of messages, each component just listens for particular high-level events.</p>

<p>Thankfully, English text appears in fixed places on the screen; TAEB never has to guess which text is prose and which represents the map. Most of the time, text only appears on the top and bottom lines. However, menus can appear in more places on the screen.</p>

<img src="http://sartak.org/misc/blog/taeb/identify.png" />

<p class="aside">Here we have an "identify" menu. The ScreenScraper can detect that there is a menu by looking at the text preceding the cursor. If it is "(end)" or "(# of #)" then TAEB knows a menu is on the screen.</p>

<p>Menus are interesting because they demand input from the rest of the system. The ScreenScraper does not know what items should be identified &mdash; it has to ask the AI component. Since there can be many menus in a particular step (such as identifying several items, one at a time), the ScreenScraper has its own loop for parsing different kinds of input. The various kinds of input include menus, prompts ("Eat what?"), location requests ("To what position do you want to be teleported?"), and ordinary top-line messages.</p>

<p>The ScreenScraper and NetHack may communicate several times before the next step is started. What is vital is that the ScreenScraper leaves NetHack in "action mode". There are no unresolved prompts, menus, <tt>--More--</tt> messages, etc. This means that the Cartographer can assume that the cursor is on TAEB. This invariant makes TAEB cope perfectly with having a different character glyph due to polymorph or invisibility. Other bots (such as "moomaster") have struggled with this, since they guessed that the white <tt>@</tt> on the screen was the character.</p>

<p>Since the ScreenScraper leaves NetHack in action mode, the Cartographer knows that every character between lines 2 and 22 inclusive are the map. If there were a menu on screen, TAEB would get massively confused, thinking there are suddenly hundreds of monsters floating in a void on the right side of the screen.</p>

<p>The Cartographer looks at each cell on the virtual terminal to update each tile in TAEB's internal map. It uses cell glyph and color to determine what is on each tile. For example, a gray <tt>{</tt> is a sink.<a href="#20090607_1"><sup>1</sup></a><a name="20090607_1-top"></a> The sink is mapped to a <tt>TAEB::World::Tile::Sink</tt> object. This sink object of course knows things every tile knows, such as how many times it has been stepped on by the character, what items are on the tile, and what engraving is on the tile. In addition, sinks know whether they have produced a black pudding, ring, or foocubus through kicking.</p>

<p>One curiosity is that the map is updated <em>after</em> we publish messages from the ScreenScraper. If TAEB moves and receives the message "You see here an opal ring", the ScreenScraper sees that and announces that there is an opal ring on the current tile. However, since the Cartographer has not run, the current tile has not been updated yet, so the item would be incorrectly added to the previous tile. The crude solution we currently use is to freeze the publisher until after the map has been updated. We are not yet sure of a better solution to this.</p>

<h3>Output</h3>

<p>At this point, the map has been updated, all input from NetHack has been parsed, and the appropriate announcements have been published. We then redraw the screen for the users watching the bot play. We also check if the user typed a key. TAEB has many debug commands, such as <tt>~</tt> to open up an interactive REPL to inspect and change TAEB's internal state.</p>

<p>Finally, it is time to involve the AI. TAEB simply asks the AI "what now?" This can involve arbitrarily complex calculations. One of my favorite features of TAEB's design is that its AI is <em>pluggable</em>. TAEB requires only a few methods be implemented by the AI, and we are working to trim that down to just "what now?"</p>

<p>There are currently two AIs being developed: Behavioral (by most of the core team) and Planar (by ais523). Both are worthy of many posts. We hope to entice more developers to work on TAEB AIs! One of our future projects will be <a href="http://interhack.us">Interhack</a> on top of TAEB. The intelligence of a <tt>TAEB::AI::Interhack</tt> would not actually be "artificial", of course.</p>

<p>Since TAEB is a <em>framework</em>, the AI will inevitably be tightly-bound to TAEB (though, as explained, the converse is not true). The AI is expected to call all sorts of methods on TAEB objects, such as "am I currently blind?" (<tt>TAEB-&gt;is_blind</tt>), "do I know the identify spell?" (<tt>TAEB-&gt;find_spell("identify")</tt>), "is there a fountain on this level?" (<tt>TAEB-&gt;current_level-&gt;has_type("fountain")</tt>), and so on. We think this is a huge boon to developers seeking to write NetHack bots &mdash; they can focus solely on the interesting bits of artificial intelligence. We handle the <em>programmatic NetHack</em>.</p>

<p>The AI tells TAEB what to do each step through <tt>TAEB::Action</tt> objects. These abstract away the details of interacting with prompts and menus. The AI can say:</p>

<pre>
    sub next_action {
        # ...
        if (my $lizard_corpse = TAEB-&gt;find_item("lizard corpse")) {
            return TAEB::Action::Eat-&gt;new(
                food =&gt; $lizard_corpse,
            );
        }
        # ...
    }
</pre>

<p>The action will take care of responding to the "Eat what?" prompt with <tt>$lizard_corpse</tt>'s inventory letter. The action will also respond to <em>unexpected</em> prompts, such as "There is a fox corpse here; eat it?". This <em>declarative</em> nature pervades TAEB's design to great effect.</p>

<p>Finally, we send the keystrokes for the current action (such as "<tt>e</tt>" for eat) to NetHack.</p>

<p>The action will participate in the next iteration of the main loop to respond to prompts and listen for events caused by the action. For example, if TAEB receives the message "You stop eating the lizard corpse", then the action will know not to remove the lizard corpse from the inventory.</p>

<h3>Conclusion</h3>

<p>The design of TAEB's main loop has had a significant impact on its (relative) longevity. The design of handling all of the input from NetHack as soon as possible drove much of the system's design in very positive ways. It encouraged the reification of Actions, which has been immeasurably useful. It even encouraged the addition of the pubsub system <em>and</em> its later enhancement to announcements. Though there are still some lingering quirks caused by this main loop design (such as teleportation traps), none seem insurmountable.</p>

<hr />

<h4>Footnotes</h4>
<ol>
    <li><a name="20090607_1"></a>TAEB remaps some dungeon features to avoid conflicts; in core NetHack, sinks are gray <tt>#</tt>, but so are corridors. Eventually we may be able to remove some remappings due to increasing Cartographer sophistication, but there's no rush. TAEB does not change too many characters as to render its NetHack screens unfamiliar. <a href="#20090607_1-top">(back)</a></li>
</ol>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>Shawn M Moore</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/06/anatomy-of-step.html#comments' onclick=''>0
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1959051115'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=8115315029840954802' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/design' rel='tag'>design</a>,
<a href='http://taeb-blog.sartak.org/search/label/taeb' rel='tag'>taeb</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-8115315029840954802"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-8115315029840954802")); } </script>

            </div></div>
          

          <div class="date-outer">
        
<h2 class='date-header'><span>Saturday, March 14, 2009</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='8969869072174743620'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/03/taeb-003.html'>TAEB 0.03</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<pre>registering upload with PAUSE web server
POSTing upload for TAEB-0.03.tar.gz
PAUSE add message sent ok [200]</pre>

<p>This is the first version that is actually going to be on the CPAN. I decided to put up with Module::Install for a little while longer. :)</p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>Shawn M Moore</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/03/taeb-003.html#comments' onclick=''>0
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1959051115'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=8969869072174743620' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/release' rel='tag'>release</a>,
<a href='http://taeb-blog.sartak.org/search/label/taeb' rel='tag'>taeb</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-8969869072174743620"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-8969869072174743620")); } </script>
<div class='post-outer'>
<div class='post hentry'>
<a name='3228866103289300435'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/03/taeb-pubsub-and-announcements.html'>TAEB, pubsub, and announcements</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<p>TAEB is a decently-sized, componentized program. Components need to be able to communicate with each other. For example, the Senses component (which tracks the state of TAEB's character) needs to know when we are indebted to a shopkeeper so that it can respond to the AI when it asks if TAEB is in debt, and for how much. The Cartographer component (which tracks the state of the dungeon map) needs to know when TAEB <i>becomes</i> indebted so it can mark the current room as a shop. In general, we want <i>any</i> component to be able to listen for <i>any</i> update. This will let us remain flexible and extensible; the completely-separate AI can listen for any update that the framework can.</p>

<p>We use the <a href="http://en.wikipedia.org/wiki/Publish-subscribe">publish-subscribe pattern</a> to control this complexity. Pubsub decouples those who generate updates (publishers) from those who listen for updates (subscribers). TAEB has been using pubsub for a long time now (since 2008-01-06, according to darcs trackdown). To publish a message, anything in the program can call <tt>TAEB-&gt;enqueue_message("foo" => @arguments)</tt>. This will call the <tt>msg_foo</tt> method on all subscribers with arguments <tt>@arguments</tt>. We have a component, Publisher, that acts as message broker.</p>

<p>Pubsub has been a great tool for letting TAEB understand messages from NetHack. We have a component that is devoted entirely to figuring out what the current state of the screen is telling us: the ScreenScraper. The ScreenScraper deals mostly with transforming characters on the screen into published messages. For example, when the NetHack prints the message "You owe (somebody) (some amount of) zorkmids.", the ScreenScraper publishes a <tt>debt</tt> message with one argument: the number of gold pieces TAEB owes. The Senses has a <tt>msg_debt</tt> method that stores this amount of debt in an attribute. The Cartographer has a <tt>msg_debt</tt> method that floodfills the current room's tiles with the shop bit. The ScreenScraper does not need to know who cares about debt. The ScreenScraper publishes a lot of messages that no component subscribes to yet, and that's okay!</p>

<p>I'm happy with this, but there is room for improvement. Simple methods are not great message handlers. There are painful bugs lurking when subscriptions interact with inheritance. Suppose the AI defines a generic "go to a specific tile" behavior. This behavior would need to handle <tt>walked</tt> so it can track TAEB's progress. This GotoTile behavior is then subclassed to produce behaviors such as GoUpstairs and GotoCorpse. GotoCorpse might need to handle <tt>walked</tt> so it can age the corpse (so that TAEB doesn't eat rotten corpses). When the publisher sends the <tt>walked</tt> message to the GotoCorpse behavior, it does <em>not</em> invoke GotoTile's <tt>msg_walked</tt> method, because GotoCorpse didn't invoke it. While you may argue that GotoCorpse <em>should</em> have known to invoke GotoTile's <tt>msg_walked</tt> as that is part of its public interface, it certainly sucks for usability. It's especially painful when GotoTile begins subscribing to <tt>walked</tt> months after GotoCorpse is written!</p>

<p>The potential fixes for this are easy. The one I like best is providing some "subscribe to a message" sugar. Where we previously wrote <tt>sub msg_walked { ... }</tt>, we would now write <tt>message walked => sub { ... }</tt>. This sugar would handle publishing to parent classes if there are any. It would still use method calls behind the scene; <tt>message</tt> would install a <tt>msg_walked</tt> method. This gives us maximum flexibility. A subscriber could define an unusual message that would only conditionally be published to its parents.</p>

<p>The arguments we pass to each method could be improved as well. It's not immediately apparent what arguments the <tt>msg_debt</tt> method would receive. Currently we pass the amount of debt. However, we should also be providing the name of the shopkeeper TAEB is indebted to. This would help the Cartographer resolve ambiguities when there are multiple rooms and shops in sight. Should we rewrite every <tt>msg_debt</tt> method (including those potentially written by third-party, unknown AI hackers) to take named parameters? Should we pass in the shopkeeper's name as the second parameter? Should we pass in the name as the <em>first</em> parameter? After all, the name does come first in the message NetHack prints. We could provide one positional parameter (amount) and one named parameter (shopkeeper). Hey wait, it would be useful to also pass which items we're buying as well...</p>

<p>The best answer is to make each message an object. We would have a <tt>TAEB::Message::Status::Debt</tt> class with attributes <tt>amount</tt> and <tt>shopkeeper</tt>. This class could have a method to ask the inventory what items are currently in TAEB's shopping cart. If we're feeling cute, we could even overload this message to stringify to the amount of debt.</p>

<p>Pubsub with objects as messages is generally called <b><a href="http://www.cincomsmalltalk.com/userblogs/vbykov/blogView?entry=3310034894">Announcements</a></b>. The concept of announcements is more general than pubsub. Announcements lets subscribers of a message communicate with the other subscribers, and even with the publisher.</p>

<p>Currently, when NetHack presents TAEB with a menu to select which items to pick up, TAEB will ask the AI whether it wants to pick up each item. The AI is asked about the item <em>without the context of the other items that it can pick up</em>. This really sucks! If TAEB is toeing the burden line, it needs to be pretty strict about what items it will pick up. This means it may refuse to pick up a useful item because there just might be an even more useful item further down the list.</p>

<p>Instead, TAEB should publish a "pick up items" announcement. This announcement, <tt>TAEB::Message::Query::PickupItems</tt>, would have the list of items. Subscribers would select which items they want by invoking methods on the announcement. When all subscribers have had a chance at it, the ScreenScraper would select the items in NetHack's menu accordingly. The selection doesn't have to be binary either; each subscriber could assign a numeric "desire" to each item. The ScreenScraper would then select items that have a sum desire greater than some cutoff (which would be another decision that some subscriber could set). Using announcements would better decouple the AI from the framework.</p>

<p>This is not the first time that turning plain strings into classes has been a major improvement for TAEB. Previously, the AI would return a string, a NetHack command, as the action to perform next. We then reified actions into classes. Letting the current action subscribe to messages, and respond to NetHack prompts, vastly improved TAEB's interactions with NetHack. Problems with unexpected prompts (such as "Eat this corpse on the ground?") quickly and completely vanished. Actions subscribing to messages lets us handle ambiguous messages better; if we just applied a unicorn horn, then we can figure out that "You feel sick." means the unicorn horn was cursed and TAEB can mark it so.</p>

<p>TAEB does not have announcements yet, but that's my next big project. I'm excited by the many possibilities here.</p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>Shawn M Moore</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/03/taeb-pubsub-and-announcements.html#comments' onclick=''>0
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1959051115'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=3228866103289300435' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/design' rel='tag'>design</a>,
<a href='http://taeb-blog.sartak.org/search/label/pubsub' rel='tag'>pubsub</a>,
<a href='http://taeb-blog.sartak.org/search/label/taeb' rel='tag'>taeb</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-3228866103289300435"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-3228866103289300435")); } </script>

            </div></div>
          

          <div class="date-outer">
        
<h2 class='date-header'><span>Monday, March 2, 2009</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='4453532986616597501'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/03/predicting-and-controlling-nethacks.html'>Predicting and controlling NetHack's randomness</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<p>NetHack, being a single-player game of imperfect knowledge, incorporates a large element of randomness. Random numbers control how much damage that minotaur will deal you, what the identity of each purple-red potion is, whether dipping into that fountain will net you a wish, etc. To generate random numbers, NetHack employs a pseudorandom number generator. Wikipedia says:</p>
<blockquote>A <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudorandom number generator</a> (PRNG) is an algorithm for generating a sequence of numbers that approximates the properties of random numbers. The sequence is not truly random in that it is completely determined by a relatively small set of initial values, called the PRNG's [seed].</blockquote>
<p>Because NetHack uses a PRNG, providing identical input to two separate games, sharing the same seed and PRNG algorithm, will lead to the same results in each game. This should not be surprising as this is a property fundamental to PRNGs. The input must be identical for both games, otherwise the games will diverge; on the same turn, casting a spell in game <i>A</i> will do a different amount of damage than simple melee in game <i>B</i>. Since the two actions use a different amount of random numbers, it would be annoying (but not difficult) to reconcile the two games.</p>
<p>NetHack uses the current time (specifically the number of seconds since midnight, January 1st, 1970) as the seed for its PRNG. Thus, two games started in the same second will have the same seed. You can verify this by typing "nethack" into two separate terminals, then quickly hitting enter in each. Once you select the same characters, you should be greeted with the same map and stats. If not, your clock may have ticked between starting the two games, so just try again. If you play both games identically you'll see that you obtain the same results in both games. You can, of course, diverge once you experience very unfavorable results in one game, such as death.</p>
<p>That's a lot of work just to fool the game. If you're going to those lengths, you're better off playing in the immortal "explore mode", or changing the code so that it's easier to win. These are some of the reasons that "public server ascensions" are more highly valued than local ascensions. You can't change the code on the server, or play in god mode, so everyone knows that your server ascensions are legitimate.</p>
<p>However, public NetHack servers still use PRNGs, so there still exist some serious exploit vectors. On the <a href="http://alt.org/nethack">nethack.alt.org</a> public server, I abused the PRNG for demonstrative purposes (though never for actual ascensions). On the <a href="http://alt.org/nethack/player-all.php?player=WowDeath">WowDeath</a> account, I killed myself by kicking wands of wishing on the first level &mdash; three times in one day.</p>
<p>Though NetHack uses the current time for its seed, it's very easy to change that to be, say, an option to NetHack. You can tell NetHack to start a game in advance, fooling it into thinking it's 11:00:00. If that game doesn't work out so well (perhaps you got a lame starting inventory), you can try again, using a seed 11:00:01. Repeat until you find a great starting haul, then start a game on the server at that exact time. I went one step further, generating thousands of starting levels until a wand of wishing was created as part of the initial level. paxed, one of the admins of nethack.alt.org, patched nethack to use a truly random seed so that this specific exploit can no longer be used on that server.</p>
<p>The trickiest part, which was the only point of failure, was in starting a game on the server at some <em>exact</em> second. Due to <a href="http://en.wikipedia.org/wiki/Clock_skew#On_a_network">clock skew</a>, the server could think it is several seconds (or even minutes) earlier or later than your clock does. The server doesn't broadcast what it thinks the current time is, either. One way to actually figure out the current time is through the random seed! Start a game on the server, noting the current time on your clock. Then generate NetHack games for that time, that time plus a second, that time minus a second, plus two seconds, and so on until you get the same starting map and stats. The offset you used is the number seconds between your machine and the server, so you can use it to know exactly when to start a server game. It's still not as exact as I would like, since you only get resolution of a second.</p>
<p>That method actually describes a distinct avenue of exploitation. Since you now have a server game and a local game with the same seed, you can play the local game (remembering to mirror the input to the server game as well) until you get to some point at which you want to diverge. It's actually more powerful than even that, because you can modify your local nethack to display object identities instead of appearances, or not require exploration for the map. You will appear to have x-ray vision or prescience to the audience of your server game.</p>
<p>This was actually how I was introduced to practical methods of exploiting nethack's PRNG. A nethacker named switch told me to start up a game and wait. He then said "See that gold in the upper right corner of the room? It has 70 gold pieces in it." That was viciously consternating. What he had done is what I described in the previous paragraph. He found my game's seed then looked at the pile of gold before I did: prescience.</p>
<p>nethack.alt.org has patched the initial seed calculation, but as nethacker Adeon has demonstrated, it's still feasible to figure out the game's seed by observing random effects. Being able to observe random effects <em>without advancing the game's state</em> is very helpful in sussing out the game's seed, since monsters moving, level messages, and many more per-turn effects use an unknowable amount of random numbers. By using something similar to the <a href="http://nethack.wikia.com/wiki/Naming_artifacts">artifact naming exploit</a>, you can observe the effects of a knowable amount of random numbers. Adeon has code that will do exactly this for server games. Once you have the seed, you're in control of the random number generator. You can trash as many random numbers as you want by using the same actions you used to figure out the seed. This will let you make every fountain quaff produce a wish by throwing out every random number that <em>wouldn't</em> produce a wish.</p>
<p>The fix for this would be to re-seed the PRNG every <i>n</i> (say, 100) random numbers. That way, well before you have a chance figure out the current seed, a new one takes its place. Re-seeding must use true random numbers. If not, the re-seeding is useless; pseudorandom seeds fall victim to the same exploits. [Update March 3rd: paxed has patched this fix into nethack.alt.org as well]</p>
<p>You might wonder why we use PRNGs at all; why not use a truly random source for every number? Unfortunately, a computer's pool of truly random numbers is very limited; it has to build up by measuring minute temperature changes or internal timing variations. NetHack, especially being played by fifty people on a public server, would keep that pool empty and harm the game's playability.</p>
<p>This type of exploit could affect many single-player games like NetHack, but I don't think there would be value in doing this for other games, since one of the preconditions is that server play is more highly valued than local play. Commercial games use closed-source servers anyway. The real applicability of these techniques is in cryptanalysis. <strong>Use truly random numbers for your keys!</strong></p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>Shawn M Moore</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/03/predicting-and-controlling-nethacks.html#comments' onclick=''>12
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1959051115'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=4453532986616597501' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/exploit' rel='tag'>exploit</a>,
<a href='http://taeb-blog.sartak.org/search/label/nethack' rel='tag'>nethack</a>,
<a href='http://taeb-blog.sartak.org/search/label/random' rel='tag'>random</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-4453532986616597501"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-4453532986616597501")); } </script>

            </div></div>
          

          <div class="date-outer">
        
<h2 class='date-header'><span>Sunday, March 1, 2009</span></h2>

          <div class="date-posts">
        
<div class='post-outer'>
<div class='post hentry'>
<a name='5119798074272052368'></a>
<h3 class='post-title entry-title'>
<a href='http://taeb-blog.sartak.org/2009/03/wheres-001.html'>Where's 0.01?</a>
</h3>
<div class='post-header-line-1'></div>
<div class='post-body entry-content'>
<p>Due to an issue with Module::Install, the 0.01 tarball I uploaded to CPAN last night was empty. I've long disliked Module::Install, so I'm going to get rid of it in favor of a plain ExtUtils::MakeMaker or something.</p>

<p>Update June 3rd, 2009: The issue with Module::Install was that it generates an empty tarball when there's no MANIFEST. More recent versions of MI are thankfully very reluctant to do that.</p>
<div style='clear: both;'></div>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'><span class='post-author vcard'>
Posted by
<span class='fn'>Shawn M Moore</span>
</span>
<span class='post-comment-link'>
<a class='comment-link' href='http://taeb-blog.sartak.org/2009/03/wheres-001.html#comments' onclick=''>0
comments</a>
</span>
<span class='post-icons'>
<span class='item-control blog-admin pid-1959051115'>
<a href='http://www.blogger.com/post-edit.g?blogID=2067582268125708908&postID=5119798074272052368' title='Edit Post'>
<img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/>
</a>
</span>
</span>
</div>
<div class='post-footer-line post-footer-line-2'><span class='post-labels'>
Labels:
<a href='http://taeb-blog.sartak.org/search/label/release' rel='tag'>release</a>,
<a href='http://taeb-blog.sartak.org/search/label/taeb' rel='tag'>taeb</a>
</span>
</div>
<div class='post-footer-line post-footer-line-3'></div>
</div>
</div>
</div>
<div id="latency-5119798074272052368"></div><script type="text/javascript">if (window['tickAboveFold']) {window['tickAboveFold'](document.getElementById("latency-5119798074272052368")); } </script>

        </div></div>
      
<!-- google_ad_section_end -->
</div>
<div class='blog-pager' id='blog-pager'>
<span id='blog-pager-older-link'>
<a class='blog-pager-older-link' href='http://taeb-blog.sartak.org/search?updated-max=2009-03-01T00%3A49%3A00-05%3A00&max-results=7' id='Blog1_blog-pager-older-link' title='Older Posts'>Older Posts</a>
</span>
<a class='home-link' href='http://taeb-blog.sartak.org/'>Home</a>
</div>
<div class='clear'></div>
<div class='blog-feeds'>
<div class='feed-links'>
Subscribe to:
<a class='feed-link' href='http://taeb-blog.sartak.org/feeds/posts/default' target='_blank' type='application/atom+xml'>Posts (Atom)</a>
</div>
</div>
</div></div>
</div>
<div id='sidebar-wrapper'>
<div class='sidebar section' id='sidebar'><div class='widget HTML' id='HTML1'>
<h2 class='title'>Developers</h2>
<div class='widget-content'>
<ul>
  <li><a href="http://sartak.org">Shawn M Moore (sartak)</a></li>
  <li><a href="http://tozt.net">Jesse Luehrs (doy)</a></li>
  <li>Stefan O'Rear (sorear)</li>
  <li><a href="http://mathemaniac.org/">Sebastian P. (Sebbe)</a></li>
  <li><a href="http://katron.org">Sean Kelly (arcanehl)</a></li>
  <li>sawtooth</li>
  <li>Alex Smith (ais523)</li>
</ul>

<a href="http://taeb.sartak.org">TAEB's site</a>
</div>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='http://www.blogger.com/rearrange?blogID=2067582268125708908&widgetType=HTML&widgetId=HTML1&action=editWidget' onclick='return _WidgetManager._PopupConfig(document.getElementById("HTML1"));' target='configHTML1' title='Edit'>
<img alt='' height='18' src='http://img1.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div><div class='widget BlogArchive' id='BlogArchive1'>
<h2>Blog Archive</h2>
<div class='widget-content'>
<div id='ArchiveList'>
<div id='BlogArchive1_ArchiveList'>
<ul class='hierarchy'>
<li class='archivedate expanded'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy toggle-open'>&#9660;&#160;</span>
</a>
<a class='post-count-link' href='http://taeb-blog.sartak.org/search?updated-min=2009-01-01T00%3A00%3A00-05%3A00&updated-max=2010-01-01T00%3A00%3A00-05%3A00&max-results=12'>2009</a>
<span class='post-count' dir='ltr'>(12)</span>
<ul class='hierarchy'>
<li class='archivedate expanded'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy toggle-open'>&#9660;&#160;</span>
</a>
<a class='post-count-link' href='http://taeb-blog.sartak.org/2009_08_01_archive.html'>August</a>
<span class='post-count' dir='ltr'>(1)</span>
<ul class='posts'>
<li><a href='http://taeb-blog.sartak.org/2009/08/planar-taeb-ai.html'>Planar - a TAEB AI</a></li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

          &#9658;&#160;
        
</span>
</a>
<a class='post-count-link' href='http://taeb-blog.sartak.org/2009_06_01_archive.html'>June</a>
<span class='post-count' dir='ltr'>(2)</span>
<ul class='posts'>
<li><a href='http://taeb-blog.sartak.org/2009/06/synchronizing-with-nethack.html'>Synchronizing with NetHack</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/06/anatomy-of-step.html'>Anatomy of a Step</a></li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

          &#9658;&#160;
        
</span>
</a>
<a class='post-count-link' href='http://taeb-blog.sartak.org/2009_03_01_archive.html'>March</a>
<span class='post-count' dir='ltr'>(4)</span>
<ul class='posts'>
<li><a href='http://taeb-blog.sartak.org/2009/03/taeb-003.html'>TAEB 0.03</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/03/taeb-pubsub-and-announcements.html'>TAEB, pubsub, and announcements</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/03/predicting-and-controlling-nethacks.html'>Predicting and controlling NetHack&#39;s randomness</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/03/wheres-001.html'>Where&#39;s 0.01?</a></li>
</ul>
</li>
</ul>
<ul class='hierarchy'>
<li class='archivedate collapsed'>
<a class='toggle' href='javascript:void(0)'>
<span class='zippy'>

          &#9658;&#160;
        
</span>
</a>
<a class='post-count-link' href='http://taeb-blog.sartak.org/2009_02_01_archive.html'>February</a>
<span class='post-count' dir='ltr'>(5)</span>
<ul class='posts'>
<li><a href='http://taeb-blog.sartak.org/2009/02/001.html'>0.01</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/02/code-stats.html'>Code stats</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/02/pretty-pictures-of-taeb-development.html'>Pretty pictures of TAEB development</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/02/modules-written-and-improved-for-taeb.html'>Modules written and improved for TAEB</a></li>
<li><a href='http://taeb-blog.sartak.org/2009/02/001-release.html'>0.01 release</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='http://www.blogger.com/rearrange?blogID=2067582268125708908&widgetType=BlogArchive&widgetId=BlogArchive1&action=editWidget' onclick='return _WidgetManager._PopupConfig(document.getElementById("BlogArchive1"));' target='configBlogArchive1' title='Edit'>
<img alt='' height='18' src='http://img1.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div>
</div><div class='widget Label' id='Label1'>
<h2>Tags</h2>
<div class='widget-content list-label-widget-content'>
<ul>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/AI'>AI</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/design'>design</a>
<span dir='ltr'>(4)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/exploit'>exploit</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/images'>images</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/library'>library</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/nethack'>nethack</a>
<span dir='ltr'>(2)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/Planar'>Planar</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/pubsub'>pubsub</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/random'>random</a>
<span dir='ltr'>(1)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/release'>release</a>
<span dir='ltr'>(4)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/taeb'>taeb</a>
<span dir='ltr'>(10)</span>
</li>
<li>
<a dir='ltr' href='http://taeb-blog.sartak.org/search/label/vcs'>vcs</a>
<span dir='ltr'>(1)</span>
</li>
</ul>
<div class='clear'></div>
<span class='widget-item-control'>
<span class='item-control blog-admin'>
<a class='quickedit' href='http://www.blogger.com/rearrange?blogID=2067582268125708908&widgetType=Label&widgetId=Label1&action=editWidget' onclick='return _WidgetManager._PopupConfig(document.getElementById("Label1"));' target='configLabel1' title='Edit'>
<img alt='' height='18' src='http://img1.blogblog.com/img/icon18_wrench_allbkg.png' width='18'/>
</a>
</span>
</span>
<div class='clear'></div>
</div>
</div></div>
</div>
<!-- spacer for skins that want sidebar and main to be the same height-->
<div class='clear'>&#160;</div>
</div>
<!-- end content-wrapper -->
</div></div>
<!-- end outer-wrapper -->
<script type="text/javascript">
if (window.jstiming) window.jstiming.load.tick('widgetJsBefore');
</script><script type="text/javascript" src="http://www.blogger.com/static/v1/widgets/512629240-widgets.js"></script>
<script type='text/javascript'>
if (typeof(BLOG_attachCsiOnload) != 'undefined' && BLOG_attachCsiOnload != null) { window['blogger_templates_experiment_id'] = "templatesV1";window['blogger_blog_id'] = '2067582268125708908';BLOG_attachCsiOnload(''); }_WidgetManager._Init('http://www.blogger.com/rearrange?blogID=2067582268125708908','http://taeb-blog.sartak.org/','2067582268125708908');
_WidgetManager._SetPageActionUrl('http://www.blogger.com/display?blogID=2067582268125708908','Ir506bZHZbnDj8gEYQb9_bNuT-o:1294339276037','AOuZoY6Nh6rn2bdYlTtZ4KKAkpP7piReOg:1294339276037');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'title': 'The Tactical Amulet Extraction Bot', 'pageType': 'index', 'url': 'http://taeb-blog.sartak.org/', 'canonicalUrl': 'http://taeb-blog.sartak.org/', 'homepageUrl': 'http://taeb-blog.sartak.org/', 'enabledCommentProfileImages': true, 'searchLabel': '', 'searchQuery': '', 'pageName': '', 'pageTitle': 'The Tactical Amulet Extraction Bot', 'encoding': 'UTF-8', 'locale': 'en', 'isPrivate': false, 'isMobile': false, 'mobileClass': '', 'languageDirection': 'ltr', 'feedLinks': '\74link rel\75\42alternate\42 type\75\42application/atom+xml\42 title\75\42The Tactical Amulet Extraction Bot - Atom\42 href\75\42http://taeb-blog.sartak.org/feeds/posts/default\42 /\76\n\74link rel\75\42alternate\42 type\75\42application/rss+xml\42 title\75\42The Tactical Amulet Extraction Bot - RSS\42 href\75\42http://taeb-blog.sartak.org/feeds/posts/default?alt\75rss\42 /\76\n\74link rel\75\42service.post\42 type\75\42application/atom+xml\42 title\75\42The Tactical Amulet Extraction Bot - Atom\42 href\75\42http://www.blogger.com/feeds/2067582268125708908/posts/default\42 /\76\n\74link rel\75\42EditURI\42 type\75\42application/rsd+xml\42 title\75\42RSD\42 href\75\42http://www.blogger.com/rsd.g?blogID\0752067582268125708908\42 /\076', 'meTag': '\74link rel\75\42me\42 href\75\42http://www.blogger.com/profile/01037423036129960255\42 /\76\n', 'openIdOpTag': '\74link rel\75\42openid.server\42 href\75\42http://www.blogger.com/openid-server.g\42 /\76\n', 'imageSrcTag': '', 'latencyHeadScript': '\74script type\75\42text/javascript\42\76(function() { var a\75window;function c(b){this.t\75{};this.tick\75function(d,i,e){e\75e?e:(new Date).getTime();this.t[d]\75[e,i]};this.tick(\42start\42,null,b)}var f\75new c;a.jstiming\75{Timer:c,load:f};try{var g\75null;if(a.chrome\46\46a.chrome.csi)g\75Math.floor(a.chrome.csi().pageT);if(g\75\75null)if(a.gtbExternal)g\75a.gtbExternal.pageT();if(g\75\75null)if(a.external)g\75a.external.pageT;if(g)a.jstiming.pt\75g}catch(h){};a.tickAboveFold\75function(b){b\75b;var d\0750;if(b.offsetParent){do d+\75b.offsetTop;while(b\75b.offsetParent)}b\75d;b\74\075750\46\46a.jstiming.load.tick(\42aft\42)};var j\75false;function k(){if(!j){j\75true;a.jstiming.load.tick(\42firstScrollTime\42)}}a.addEventListener?a.addEventListener(\42scroll\42,k,false):a.attachEvent(\42onscroll\42,k);\n })();\74/script\076', 'mobileHeadScript': ''}}]);
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML1', 'sidebar', null, document.getElementById('HTML1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogArchiveView', new _WidgetInfo('BlogArchive1', 'sidebar', null, document.getElementById('BlogArchive1'), {'languageDirection': 'ltr'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_LabelView', new _WidgetInfo('Label1', 'sidebar', null, document.getElementById('Label1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'main'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main'));
</script>
</body>
</html>